/*
 * Comando administrativo para gesti√≥n avanzada del sistema
 */

const { SlashCommandBuilder, PermissionFlagsBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const statsManager = require('../utils/StatsManager');
const languageManager = require('../utils/LanguageManager');
const fs = require('fs').promises;
const path = require('path');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('üîß Comandos administrativos del sistema de tickets')
        .addSubcommand(subcommand =>
            subcommand
                .setName('backup')
                .setDescription('Crear respaldo de datos')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('restore')
                .setDescription('Restaurar datos desde respaldo')
                .addAttachmentOption(option =>
                    option.setName('archivo')
                        .setDescription('Archivo de respaldo')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('maintenance')
                .setDescription('Activar/desactivar modo mantenimiento')
                .addBooleanOption(option =>
                    option.setName('estado')
                        .setDescription('true = activar, false = desactivar')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('cleanup')
                .setDescription('Limpiar datos antiguos')
                .addIntegerOption(option =>
                    option.setName('dias')
                        .setDescription('Eliminar datos m√°s antiguos que X d√≠as')
                        .setMinValue(30)
                        .setMaxValue(365)
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('config')
                .setDescription('Ver/modificar configuraci√≥n del sistema')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('health')
                .setDescription('Verificar salud del sistema')
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
        .setDMPermission(false),

    async execute(interaction) {
        try {
            // Solo administradores
            if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
                return interaction.reply({
                    content: '‚ùå Solo administradores pueden usar comandos administrativos.',
                    ephemeral: true
                });
            }

            const subcommand = interaction.options.getSubcommand();
            await interaction.deferReply({ ephemeral: true });

            switch (subcommand) {
                case 'backup':
                    await this.handleBackup(interaction);
                    break;
                case 'restore':
                    await this.handleRestore(interaction);
                    break;
                case 'maintenance':
                    await this.handleMaintenance(interaction);
                    break;
                case 'cleanup':
                    await this.handleCleanup(interaction);
                    break;
                case 'config':
                    await this.handleConfig(interaction);
                    break;
                case 'health':
                    await this.handleHealth(interaction);
                    break;
            }

        } catch (error) {
            console.error('Error en comando admin:', error);
            await interaction.editReply({
                content: '‚ùå Error ejecutando comando administrativo.'
            }).catch(console.error);
        }
    },

    async handleBackup(interaction) {
        try {
            const backupData = {
                timestamp: Date.now(),
                version: '1.0.0',
                guildId: interaction.guild.id,
                guildName: interaction.guild.name,
                data: {}
            };

            // Respaldar tickets
            const ticketsPath = path.join(__dirname, '../data/tickets.json');
            try {
                const ticketsData = await fs.readFile(ticketsPath, 'utf-8');
                backupData.data.tickets = JSON.parse(ticketsData);
            } catch (error) {
                backupData.data.tickets = {};
            }

            // Respaldar estad√≠sticas
            const statsPath = path.join(__dirname, '../data/stats.json');
            try {
                const statsData = await fs.readFile(statsPath, 'utf-8');
                backupData.data.stats = JSON.parse(statsData);
            } catch (error) {
                backupData.data.stats = {};
            }

            // Respaldar configuraci√≥n de idiomas
            const langPath = path.join(__dirname, '../data/language_settings.json');
            try {
                const langData = await fs.readFile(langPath, 'utf-8');
                backupData.data.languages = JSON.parse(langData);
            } catch (error) {
                backupData.data.languages = {};
            }

            // Crear archivo de respaldo
            const backupFileName = `backup_${interaction.guild.id}_${new Date().toISOString().split('T')[0]}.json`;
            const backupPath = path.join(__dirname, '../data/backups', backupFileName);
            
            // Asegurar directorio de respaldos
            await fs.mkdir(path.dirname(backupPath), { recursive: true });
            await fs.writeFile(backupPath, JSON.stringify(backupData, null, 2));

            const embed = new EmbedBuilder()
                .setTitle('üíæ Respaldo Completado')
                .setDescription('Todos los datos han sido respaldados exitosamente')
                .setColor('#00FF00')
                .addFields(
                    {
                        name: 'üìä Datos Incluidos',
                        value: '‚Ä¢ Tickets y metadatos\n‚Ä¢ Estad√≠sticas hist√≥ricas\n‚Ä¢ Configuraci√≥n de idiomas\n‚Ä¢ Configuraci√≥n del sistema',
                        inline: true
                    },
                    {
                        name: 'üìÖ Informaci√≥n del Respaldo',
                        value: `**Servidor:** ${interaction.guild.name}\n**Fecha:** ${new Date().toLocaleString()}\n**Archivo:** ${backupFileName}`,
                        inline: true
                    }
                )
                .setFooter({
                    text: 'Guarda este archivo en un lugar seguro'
                })
                .setTimestamp();

            await interaction.editReply({ 
                embeds: [embed],
                files: [{
                    attachment: backupPath,
                    name: backupFileName
                }]
            });

            console.log(`üíæ Respaldo creado por ${interaction.user.tag} para ${interaction.guild.name}`);

        } catch (error) {
            console.error('Error creando respaldo:', error);
            await interaction.editReply({
                content: '‚ùå Error creando el respaldo de datos.'
            });
        }
    },

    async handleRestore(interaction) {
        const attachment = interaction.options.getAttachment('archivo');
        
        if (!attachment.name.endsWith('.json')) {
            return interaction.editReply({
                content: '‚ùå El archivo debe ser un respaldo JSON v√°lido.'
            });
        }

        try {
            // Descargar y validar archivo
            const response = await fetch(attachment.url);
            const backupData = await response.json();

            // Validar estructura del respaldo
            if (!backupData.data || !backupData.timestamp) {
                return interaction.editReply({
                    content: '‚ùå Archivo de respaldo inv√°lido o corrupto.'
                });
            }

            // Crear respaldo de seguridad antes de restaurar
            await this.createSafetyBackup(interaction.guild.id);

            // Restaurar datos
            if (backupData.data.tickets) {
                const ticketsPath = path.join(__dirname, '../data/tickets.json');
                await fs.writeFile(ticketsPath, JSON.stringify(backupData.data.tickets, null, 2));
            }

            if (backupData.data.stats) {
                const statsPath = path.join(__dirname, '../data/stats.json');
                await fs.writeFile(statsPath, JSON.stringify(backupData.data.stats, null, 2));
            }

            if (backupData.data.languages) {
                const langPath = path.join(__dirname, '../data/language_settings.json');
                await fs.writeFile(langPath, JSON.stringify(backupData.data.languages, null, 2));
            }

            const embed = new EmbedBuilder()
                .setTitle('‚ôªÔ∏è Restauraci√≥n Completada')
                .setDescription('Los datos han sido restaurados exitosamente')
                .setColor('#00FF00')
                .addFields(
                    {
                        name: 'üìã Datos Restaurados',
                        value: `‚Ä¢ ${Object.keys(backupData.data.tickets || {}).length} tickets\n‚Ä¢ Estad√≠sticas hist√≥ricas\n‚Ä¢ Configuraci√≥n personalizada`,
                        inline: true
                    },
                    {
                        name: 'üìÖ Informaci√≥n del Respaldo',
                        value: `**Origen:** ${backupData.guildName || 'N/A'}\n**Fecha:** ${new Date(backupData.timestamp).toLocaleString()}\n**Versi√≥n:** ${backupData.version || '1.0.0'}`,
                        inline: true
                    }
                )
                .addFields({
                    name: '‚ö†Ô∏è Importante',
                    value: 'Se cre√≥ un respaldo de seguridad autom√°tico antes de la restauraci√≥n. Reinicia el bot para aplicar todos los cambios.',
                    inline: false
                })
                .setTimestamp();

            await interaction.editReply({ embeds: [embed] });

            console.log(`‚ôªÔ∏è Datos restaurados por ${interaction.user.tag} en ${interaction.guild.name}`);

        } catch (error) {
            console.error('Error restaurando datos:', error);
            await interaction.editReply({
                content: '‚ùå Error procesando el archivo de respaldo. Verifica que sea un respaldo v√°lido.'
            });
        }
    },

    async handleMaintenance(interaction) {
        const maintenanceMode = interaction.options.getBoolean('estado');
        const configPath = path.join(__dirname, '../data/config.json');
        
        try {
            let config = {};
            try {
                const configData = await fs.readFile(configPath, 'utf-8');
                config = JSON.parse(configData);
            } catch (error) {
                // Si no existe el archivo, crear uno nuevo
            }

            config.maintenanceMode = {
                enabled: maintenanceMode,
                activatedBy: interaction.user.id,
                activatedAt: Date.now(),
                reason: 'Activado por comando administrativo'
            };

            await fs.writeFile(configPath, JSON.stringify(config, null, 2));

            const embed = new EmbedBuilder()
                .setTitle(`üîß Modo Mantenimiento ${maintenanceMode ? 'Activado' : 'Desactivado'}`)
                .setDescription(maintenanceMode ? 
                    'El sistema de tickets est√° ahora en mantenimiento. Los usuarios no podr√°n crear nuevos tickets.' :
                    'El sistema de tickets est√° operativo nuevamente.'
                )
                .setColor(maintenanceMode ? '#FF6B6B' : '#00FF00')
                .addFields({
                    name: 'üìä Estado',
                    value: maintenanceMode ? 'üî¥ Mantenimiento' : 'üü¢ Operativo',
                    inline: true
                })
                .setFooter({
                    text: `Cambiado por ${interaction.user.tag}`
                })
                .setTimestamp();

            await interaction.editReply({ embeds: [embed] });

            // Notificar en el canal de logs si est√° configurado
            const logsChannel = interaction.guild.channels.cache.get('TU-LOG-CHANNEL-ID');
            if (logsChannel) {
                await logsChannel.send({ embeds: [embed] });
            }

            console.log(`üîß Modo mantenimiento ${maintenanceMode ? 'activado' : 'desactivado'} por ${interaction.user.tag}`);

        } catch (error) {
            console.error('Error configurando modo mantenimiento:', error);
            await interaction.editReply({
                content: '‚ùå Error configurando el modo mantenimiento.'
            });
        }
    },

    async handleCleanup(interaction) {
        const days = interaction.options.getInteger('dias');
        const cutoffDate = Date.now() - (days * 24 * 60 * 60 * 1000);

        try {
            // Limpiar tickets antiguos
            const ticketsPath = path.join(__dirname, '../data/tickets.json');
            let ticketsDB = {};
            let cleanedTickets = 0;

            try {
                const ticketsData = await fs.readFile(ticketsPath, 'utf-8');
                ticketsDB = JSON.parse(ticketsData);

                // Contar y eliminar tickets antiguos cerrados
                const ticketEntries = Object.entries(ticketsDB).filter(([key]) => !key.startsWith('_'));
                
                for (const [channelId, ticketData] of ticketEntries) {
                    if (ticketData.closedAt && ticketData.closedAt < cutoffDate) {
                        delete ticketsDB[channelId];
                        cleanedTickets++;
                    }
                }

                await fs.writeFile(ticketsPath, JSON.stringify(ticketsDB, null, 2));
            } catch (error) {
                console.error('Error limpiando tickets:', error);
            }

            // Limpiar transcripciones antiguas
            const transcriptsPath = path.join(__dirname, '../data/transcripts');
            let cleanedTranscripts = 0;

            try {
                const transcriptFiles = await fs.readdir(transcriptsPath);
                
                for (const file of transcriptFiles) {
                    const filePath = path.join(transcriptsPath, file);
                    const stats = await fs.stat(filePath);
                    
                    if (stats.mtime.getTime() < cutoffDate) {
                        await fs.unlink(filePath);
                        cleanedTranscripts++;
                    }
                }
            } catch (error) {
                console.error('Error limpiando transcripciones:', error);
            }

            const embed = new EmbedBuilder()
                .setTitle('üßπ Limpieza Completada')
                .setDescription(`Datos m√°s antiguos que ${days} d√≠as han sido eliminados`)
                .setColor('#00FF00')
                .addFields(
                    {
                        name: 'üé´ Tickets Eliminados',
                        value: cleanedTickets.toString(),
                        inline: true
                    },
                    {
                        name: 'üìã Transcripciones Eliminadas',
                        value: cleanedTranscripts.toString(),
                        inline: true
                    },
                    {
                        name: 'üìÖ Fecha de Corte',
                        value: new Date(cutoffDate).toLocaleDateString(),
                        inline: true
                    }
                )
                .addFields({
                    name: 'üí° Nota',
                    value: 'Solo se eliminaron tickets cerrados y sus transcripciones asociadas. Los tickets abiertos se mantuvieron intactos.',
                    inline: false
                })
                .setTimestamp();

            await interaction.editReply({ embeds: [embed] });

            console.log(`üßπ Limpieza ejecutada por ${interaction.user.tag}: ${cleanedTickets} tickets, ${cleanedTranscripts} transcripciones`);

        } catch (error) {
            console.error('Error en limpieza:', error);
            await interaction.editReply({
                content: '‚ùå Error ejecutando la limpieza de datos.'
            });
        }
    },

    async handleConfig(interaction) {
        const configPath = path.join(__dirname, '../data/config.json');
        
        try {
            let config = {};
            try {
                const configData = await fs.readFile(configPath, 'utf-8');
                config = JSON.parse(configData);
            } catch (error) {
                config = {
                    version: '1.0.0',
                    maintenanceMode: { enabled: false },
                    features: {
                        autoTranscripts: true,
                        prioritySystem: true,
                        notifications: true,
                        statistics: true
                    }
                };
            }

            const embed = new EmbedBuilder()
                .setTitle('‚öôÔ∏è Configuraci√≥n del Sistema')
                .setDescription('Estado actual de la configuraci√≥n')
                .setColor('#FFD700')
                .addFields(
                    {
                        name: 'üîß Estado del Sistema',
                        value: config.maintenanceMode?.enabled ? 'üî¥ Mantenimiento' : 'üü¢ Operativo',
                        inline: true
                    },
                    {
                        name: 'üìä Versi√≥n',
                        value: config.version || '1.0.0',
                        inline: true
                    },
                    {
                        name: 'üè¢ Servidor',
                        value: interaction.guild.name,
                        inline: true
                    }
                );

            // Mostrar funcionalidades
            if (config.features) {
                let featuresText = '';
                Object.entries(config.features).forEach(([feature, enabled]) => {
                    const emoji = enabled ? '‚úÖ' : '‚ùå';
                    const name = feature.replace(/([A-Z])/g, ' $1').toLowerCase();
                    featuresText += `${emoji} ${name.charAt(0).toUpperCase() + name.slice(1)}\n`;
                });

                embed.addFields({
                    name: 'üéõÔ∏è Funcionalidades',
                    value: featuresText,
                    inline: false
                });
            }

            // Botones para configuraci√≥n r√°pida
            const buttons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('config_edit')
                        .setLabel('‚úèÔ∏è Editar')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('config_reset')
                        .setLabel('üîÑ Restablecer')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('config_export')
                        .setLabel('üì§ Exportar')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.editReply({ embeds: [embed], components: [buttons] });

        } catch (error) {
            console.error('Error obteniendo configuraci√≥n:', error);
            await interaction.editReply({
                content: '‚ùå Error accediendo a la configuraci√≥n del sistema.'
            });
        }
    },

    async handleHealth(interaction) {
        const healthChecks = [];

        // Verificar archivos esenciales
        const essentialFiles = [
            '../data/tickets.json',
            '../data/stats.json',
            '../locales/es.json',
            '../locales/en.json'
        ];

        for (const file of essentialFiles) {
            const filePath = path.join(__dirname, file);
            try {
                await fs.access(filePath);
                healthChecks.push({
                    name: path.basename(file),
                    status: '‚úÖ OK',
                    message: 'Archivo accesible'
                });
            } catch (error) {
                healthChecks.push({
                    name: path.basename(file),
                    status: '‚ùå ERROR',
                    message: 'Archivo no encontrado'
                });
            }
        }

        // Verificar permisos del bot
        const requiredPermissions = [
            'ViewChannel',
            'SendMessages',
            'ManageChannels',
            'ManageRoles',
            'EmbedLinks',
            'AttachFiles'
        ];

        const botPermissions = interaction.guild.members.me.permissions;
        const missingPermissions = requiredPermissions.filter(perm => 
            !botPermissions.has(perm)
        );

        healthChecks.push({
            name: 'Permisos del Bot',
            status: missingPermissions.length === 0 ? '‚úÖ OK' : '‚ö†Ô∏è ADVERTENCIA',
            message: missingPermissions.length === 0 ? 
                'Todos los permisos requeridos est√°n disponibles' :
                `Faltan: ${missingPermissions.join(', ')}`
        });

        // Verificar estad√≠sticas del sistema
        try {
            const stats = await statsManager.getSummaryStats();
            healthChecks.push({
                name: 'Sistema de Estad√≠sticas',
                status: '‚úÖ OK',
                message: `${stats.totalTickets} tickets registrados`
            });
        } catch (error) {
            healthChecks.push({
                name: 'Sistema de Estad√≠sticas',
                status: '‚ùå ERROR',
                message: 'Error accediendo a estad√≠sticas'
            });
        }

        // Calcular estado general
        const hasErrors = healthChecks.some(check => check.status.includes('ERROR'));
        const hasWarnings = healthChecks.some(check => check.status.includes('ADVERTENCIA'));
        
        let overallStatus = 'üü¢ SALUDABLE';
        let overallColor = '#00FF00';
        
        if (hasErrors) {
            overallStatus = 'üî¥ ERRORES DETECTADOS';
            overallColor = '#FF0000';
        } else if (hasWarnings) {
            overallStatus = 'üü° ADVERTENCIAS';
            overallColor = '#FFD700';
        }

        const embed = new EmbedBuilder()
            .setTitle('üè• Estado del Sistema')
            .setDescription(`**Estado General:** ${overallStatus}`)
            .setColor(overallColor)
            .setTimestamp();

        // A√±adir resultados de verificaciones
        healthChecks.forEach(check => {
            embed.addFields({
                name: check.status + ' ' + check.name,
                value: check.message,
                inline: true
            });
        });

        // Informaci√≥n adicional del sistema
        embed.addFields({
            name: 'üìä Informaci√≥n del Bot',
            value: `**Uptime:** ${this.formatUptime(process.uptime())}\n**Memoria:** ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)} MB\n**Node.js:** ${process.version}`,
            inline: false
        });

        await interaction.editReply({ embeds: [embed] });
    },

    async createSafetyBackup(guildId) {
        try {
            const safetyBackupPath = path.join(__dirname, '../data/backups', `safety_backup_${guildId}_${Date.now()}.json`);
            
            const backupData = {
                timestamp: Date.now(),
                type: 'safety_backup',
                guildId: guildId
            };

            // Respaldar datos existentes
            const ticketsPath = path.join(__dirname, '../data/tickets.json');
            try {
                const ticketsData = await fs.readFile(ticketsPath, 'utf-8');
                backupData.tickets = JSON.parse(ticketsData);
            } catch (error) {
                backupData.tickets = {};
            }

            await fs.mkdir(path.dirname(safetyBackupPath), { recursive: true });
            await fs.writeFile(safetyBackupPath, JSON.stringify(backupData, null, 2));
            
            console.log(`üíæ Respaldo de seguridad creado: ${safetyBackupPath}`);
        } catch (error) {
            console.error('Error creando respaldo de seguridad:', error);
        }
    },

    formatUptime(seconds) {
        const days = Math.floor(seconds / (24 * 60 * 60));
        const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));
        const minutes = Math.floor((seconds % (60 * 60)) / 60);
        
        if (days > 0) {
            return `${days}d ${hours}h ${minutes}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes}m`;
        } else {
            return `${minutes}m`;
        }
    }
};